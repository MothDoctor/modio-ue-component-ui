"use strict";(self.webpackChunkmodio_docs=self.webpackChunkmodio_docs||[]).push([[38],{48361:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>a});var i=t(74848),o=t(28453);const s={id:"ue-custom-components",title:"Creating Custom Components",slug:"/unreal/component-ui/custom-components/",custom_edit_url:"https://github.com/modio/modio-ue4-internal/tree/main/Plugins/ModioComponentUI/Doc/component-ui/custom_components.mdx"},r=void 0,d={id:"component-ui/ue-custom-components",title:"Creating Custom Components",description:"The previous guide explains how interfaces are used throughout WBP_ModioModBrowser to enable easy customization by substituting mod.io components for your own custom components.  There are 3 ways to create a custom component for use in the mod.io component UI framework:",source:"@site/public/en-us/component-ui/custom_components.mdx",sourceDirName:"component-ui",slug:"/unreal/component-ui/custom-components/",permalink:"/unreal/component-ui/custom-components/",draft:!1,unlisted:!1,editUrl:"https://github.com/modio/modio-ue4-internal/tree/main/Plugins/ModioComponentUI/Doc/component-ui/custom_components.mdx",tags:[],version:"current",frontMatter:{id:"ue-custom-components",title:"Creating Custom Components",slug:"/unreal/component-ui/custom-components/",custom_edit_url:"https://github.com/modio/modio-ue4-internal/tree/main/Plugins/ModioComponentUI/Doc/component-ui/custom_components.mdx"},sidebar:"sidebar",previous:{title:"Substituting Components in the Template Mod Browser",permalink:"/unreal/component-ui/substitute-components/"},next:{title:"Framework Elements in Detail",permalink:"/unreal/component-ui/architecture/"}},l={},a=[{value:"Wrapping an existing widget",id:"wrapping-an-existing-widget",level:3},{value:"Wrapping an existing button",id:"wrapping-an-existing-button",level:4},{value:"Creating a new widget",id:"creating-a-new-widget",level:3},{value:"Creating a labelled button",id:"creating-a-labelled-button",level:4},{value:"Subclassing an existing widget",id:"subclassing-an-existing-widget",level:3},{value:"Subclassing <code>UProgressBar</code>",id:"subclassing-uprogressbar",level:4}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/unreal/component-ui/substitute-components/",children:"The previous guide"})," explains how interfaces are used throughout ",(0,i.jsx)(n.code,{children:"WBP_ModioModBrowser"})," to enable easy customization by substituting mod.io components for your own custom components.  There are 3 ways to create a custom component for use in the mod.io component UI framework:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Wrapping an existing ",(0,i.jsx)(n.code,{children:"UWidget"})," or ",(0,i.jsx)(n.code,{children:"UUserWidget"})," (including derived classes) and implementing the required interfaces on the wrapper"]}),"\n",(0,i.jsxs)(n.li,{children:["Creating a new ",(0,i.jsx)(n.code,{children:"UWidget"})," or ",(0,i.jsx)(n.code,{children:"UUserWidget"})," (including derived classes) and implementing the required interfaces in the new widget"]}),"\n",(0,i.jsxs)(n.li,{children:["Subclassing an existing ",(0,i.jsx)(n.code,{children:"UWidget"})," or ",(0,i.jsx)(n.code,{children:"UUserWidget"})," (including derived classes) and applying the mod.io interfaces directly"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"wrapping-an-existing-widget",children:"Wrapping an existing widget"}),"\n",(0,i.jsx)(n.p,{children:"Wrapping an existing widget is the simplest and easiest way to ensure consistency of behaviour and styling between the mod browser and the rest of the project. This option is useful if you already have a set of UI widgets in your game which you would also like to use in your mod browser. By non-intrusively wrapping these widgets, the style and function of the original widget remains intact."}),"\n",(0,i.jsx)(n.h4,{id:"wrapping-an-existing-button",children:"Wrapping an existing button"}),"\n",(0,i.jsx)(n.p,{children:"This example demonstrates wrapping an existing simple Common UI button:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Widget Blueprint of simple button",src:t(16974).A+"",width:"1271",height:"770"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Create a new ",(0,i.jsx)(n.strong,{children:"Widget Blueprint"})," in the Unreal Editor.  Select ",(0,i.jsx)(n.strong,{children:"User Widget"})," as its parent. Add the existing widget into the hierarchy."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Widget Blueprint of wrapped widget",src:t(47534).A+"",width:"1266",height:"764"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["Check the ",(0,i.jsx)(n.a,{href:"/unreal/ui-refdocs/",children:"UI documentation"})," for a list of the expected interfaces for the widget you're looking to replace.  The ",(0,i.jsx)(n.a,{href:"/unreal/ui-refdocs/#button",children:"documentation for a button"})," specifies the following interfaces:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IModioUIClickableWidget"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IModioUISelectableWidget"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IModioUIHoverableWidget"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IModioUIHasTooltipWidget"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IModioUIDataSourceWidget"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Add these interfaces to the wrapped Widget Blueprint in ",(0,i.jsx)(n.strong,{children:"Class Settings"})," under ",(0,i.jsx)(n.strong,{children:"Details -> Interfaces -> Implemented Interfaces"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Adding interfaces to a Widget Blueprint",src:t(91848).A+"",width:"1014",height:"1079"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"Implement the required interface functions.  Generally this involves forwarding on the interface function calls to the inner widget."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Some functions, such as ",(0,i.jsx)(n.code,{children:"SetSelectedState()"}),", can be directly called on the inner widget:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Set selected state",src:t(70835).A+"",width:"1518",height:"640"})}),"\n",(0,i.jsxs)(n.p,{children:["Others, such as ",(0,i.jsx)(n.code,{children:"AddClickedHandler()"}),", may require the use of event dispatchers."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"IModioUIClickableWidget.h"})," shows that ",(0,i.jsx)(n.code,{children:"AddClickedHandler()"})," expects a handler of type ",(0,i.jsx)(n.code,{children:"FModioClickableOnClicked"})," \u2014 a dynamic delegate with one ",(0,i.jsx)(n.code,{children:"UObject*"})," parameter."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'DECLARE_DYNAMIC_DELEGATE_OneParam(FModioClickableOnClicked, UObject*, ClickContext);\n\nUFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "mod.io|UI|Events|Clickable")\nvoid AddClickedHandler(const FModioClickableOnClicked& Handler);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To forward this interface function call, create an ",(0,i.jsx)(n.code,{children:"OnClicked"})," event dispatcher for the wrapped widget that also takes an ",(0,i.jsx)(n.code,{children:"Object"})," reference:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Add clicked handler",src:t(73098).A+"",width:"512",height:"604"})}),"\n",(0,i.jsxs)(n.p,{children:["When the ",(0,i.jsx)(n.code,{children:"AddClickedHandler()"})," event is invoked, it can assign ",(0,i.jsx)(n.code,{children:"Handler"})," to ",(0,i.jsx)(n.code,{children:"OnClicked"}),":"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Add clicked handler",src:t(39353).A+"",width:"962",height:"433"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"RemoveClickedHandler()"})," is implemented in the same way:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Add clicked handler",src:t(74756).A+"",width:"1027",height:"433"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"OnClicked"})," can then be called whenever the inner widget's ",(0,i.jsx)(n.code,{children:"OnButtonBaseClicked"})," event is invoked:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Calling OnClicked",src:t(10431).A+"",width:"1117",height:"447"})}),"\n",(0,i.jsx)(n.p,{children:"Once the required interface functions are implemented, the widget is ready for use."}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-new-widget",children:"Creating a new widget"}),"\n",(0,i.jsxs)(n.p,{children:["The mod.io component UI framework ",(0,i.jsx)(n.a,{href:"/unreal/component-ui/principles/#emphasise-flexibility-and-composability-for-widgets",children:"emphasises flexibility and composability for widgets"}),".  This allows developers to easily create new widgets by combining existing components."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"This example uses generic Unreal Engine widgets, but you can use mod.io components or a combination of both as long as the required interfaces are correctly implemented!"})}),"\n",(0,i.jsx)(n.h4,{id:"creating-a-labelled-button",children:"Creating a labelled button"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["If using C++, create a new ",(0,i.jsx)(n.code,{children:"UWidget"}),"-derived class such as ",(0,i.jsx)(n.code,{children:"UUserWidget"}),".  Alternatively, you can skip straight to step 5 and implement this widget in Blueprint only."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Refer to the ",(0,i.jsx)(n.a,{href:"/unreal/ui-refdocs/",children:"UI documentation"})," for a list of the expected interfaces for the widget you're looking to create. For brevity, this example will focus on ",(0,i.jsx)(n.code,{children:"IModioUIClickableWidget"})," and ",(0,i.jsx)(n.code,{children:"IModioUIHasTextWidget"})," interfaces."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add the underlying components that will actually implement the behaviour of the outer component."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Override any functions that you wish to implement in C++, and add any required variables and helper functions.  This example adds ",(0,i.jsx)(n.code,{children:"FModioClickableOnClickedMulticast OnClicked"})," for use with ",(0,i.jsx)(n.code,{children:"AddClickedHandler()"}),", and ",(0,i.jsx)(n.code,{children:"FText DefaultLabel"})," so that an outer widget can set a default label in the editor details rather than relying on runtime changes."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Your component should look something like this:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"MyTextButtonComponent.h"}),":"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n\n#include "Blueprint/UserWidget.h"\n#include "Components/Button.h"\n#include "Components/TextBlock.h"\n#include "CoreMinimal.h"\n#include "UI/Interfaces/IModioUIClickableWidget.h"\n#include "UI/Interfaces/IModioUIHasTextWidget.h"\n\n#include "MyTextButtonComponent.generated.h"\n\nUCLASS()\nclass MODIOUICORE_API UMyTextButtonComponent : public UUserWidget, public IModioUIClickableWidget, public IModioUIHasTextWidget\n{\n   GENERATED_BODY()\n\npublic:\n   virtual void NativePreConstruct() override;\n\n   UPROPERTY()\n   FModioClickableOnClickedMulticast OnClicked;\n\n   UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = "MyGame")\n   FText LabelText = FText::FromString("Button");\n\n   void NotifyClicked();\n\n   UFUNCTION()\n   void OnInternalButtonClicked();\n\n   // IModioUIClickableWidget Interface\n   virtual void AddClickedHandler_Implementation(const FModioClickableOnClicked& Handler) override;\n   virtual void RemoveClickedHandler_Implementation(const FModioClickableOnClicked& Handler) override;\n\n   // IModioUIHasTextWidget Interface\n   virtual void NativeSetText(const FText& DisplayText) override;\n   virtual FText NativeGetText() override;\n\n   // Internal components\n   UPROPERTY(BlueprintReadOnly, meta = (BindWidget))\n   TObjectPtr<UTextBlock> InternalLabel;\n   UPROPERTY(BlueprintReadOnly, meta = (BindWidget))\n   TObjectPtr<UButton> InternalButton;\n};\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"MyTextButtonComponent.cpp"}),":"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "UI/Components/Buttons/MyTextButtonComponent.h"\n\nvoid UMyTextButtonComponent::AddClickedHandler_Implementation(const FModioClickableOnClicked& Handler)\n{\n   OnClicked.AddUnique(Handler);\n}\nvoid UMyTextButtonComponent::RemoveClickedHandler_Implementation(const FModioClickableOnClicked& Handler)\n{\n   OnClicked.Remove(Handler);\n}\nvoid UMyTextButtonComponent::NotifyClicked()\n{\n   // Provide a reference to the implementing widget, not the specific internal widget that was clicked\n   OnClicked.Broadcast(this);\n}\nvoid UMyTextButtonComponent::OnInternalButtonClicked()\n{\n   NotifyClicked();\n}\nvoid UMyTextButtonComponent::NativePreConstruct()\n{\n   Super::NativePreConstruct();\n   Execute_SetWidgetText(this, LabelText);\n   if (InternalButton)\n   {\n   \tInternalButton->OnClicked.AddDynamic(this, &UMyTextButtonComponent::OnInternalButtonClicked);\n   }\n}\nvoid UMyTextButtonComponent::NativeSetText(const FText& DisplayText)\n{\n   if (InternalLabel)\n   {\n   \tInternalLabel->SetText(DisplayText);\n   }\n}\nFText UMyTextButtonComponent::NativeGetText()\n{\n   if (InternalLabel)\n   {\n   \treturn InternalLabel->GetText();\n   }\n   return FText();\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Interface functions can be implemented in C++, Blueprint, or both.  For brevity, this example only implements a few of the available interface functions."})}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsxs)(n.li,{children:["Create a new Widget Blueprint derived from your newly created C++ class, or from User Widget if you have chosen not to create a base C++ class. If implementing in Blueprint only, add the required interfaces to your widget in ",(0,i.jsx)(n.strong,{children:"Class Settings."})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Create Widget Blueprint of new component",src:t(38684).A+"",width:"934",height:"532"})}),"\n",(0,i.jsxs)(n.ol,{start:"6",children:["\n",(0,i.jsx)(n.li,{children:"Add the required internal components: Button and Text Block. Style your component as desired."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Create Widget Blueprint of new component",src:t(30382).A+"",width:"1486",height:"932"})}),"\n",(0,i.jsxs)(n.ol,{start:"7",children:["\n",(0,i.jsx)(n.li,{children:"Implement any remaining interface functions.  You may override native functions, or implement functions that have been omitted from the native implementation.  Once the required interface functions are implemented, the widget is ready for use."}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Refer to the ",(0,i.jsx)(n.a,{href:"/unreal/component-ui/custom-components/#wrapping-an-existing-button",children:(0,i.jsx)(n.strong,{children:"Wrapping an existing button"})})," section for a demonstration of implementing interface functions in Blueprint."]})}),"\n",(0,i.jsx)(n.h3,{id:"subclassing-an-existing-widget",children:"Subclassing an existing widget"}),"\n",(0,i.jsx)(n.p,{children:"This is the most intrusive option, but it avoids the need to create an additional class within the project.  This example subclasses an Unreal Engine progress bar and adds the required interfaces to the new child class."}),"\n",(0,i.jsxs)(n.h4,{id:"subclassing-uprogressbar",children:["Subclassing ",(0,i.jsx)(n.code,{children:"UProgressBar"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Create a new C++ class with ",(0,i.jsx)(n.code,{children:"UProgressBar"})," as its parent."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The Component UI documentation states that a ",(0,i.jsx)(n.a,{href:"/unreal/ui-refdocs/#progress",children:"Progress component"})," requires just one interface \u2014 ",(0,i.jsx)(n.code,{children:"IModioUIProgressWidget"}),".  Add this to your subclassed progress bar."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Add the interface functions, a ",(0,i.jsx)(n.code,{children:"FModioProgressWidgetValueChangedMulticast"})," delegate for binding to add/remove handler events, and a ",(0,i.jsx)(n.code,{children:"TOptional<FLinearColor>"})," to store a default color.  Your header file should look something like this:"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"MyProgressBar.h"})}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#pragma once\n\n#include "Components/ProgressBar.h"\n#include "CoreMinimal.h"\n#include "UI/Interfaces/IModioUIProgressWidget.h"\n\n#include "MyProgressBar.generated.h"\n\nUCLASS()\nclass MODIOUICORE_API UMyProgressBar : public UProgressBar, public IModioUIProgressWidget\n{\n   GENERATED_BODY()\n\npublic:\n\n   UPROPERTY()\n   FModioProgressWidgetValueChangedMulticast OnProgressValueChanged;\n\n   TOptional<FLinearColor> DefaultFillColor;\n\n   virtual void AddValueChangedHandler_Implementation(const FModioProgressWidgetValueChanged& Handler) override;\n   virtual void RemoveValueChangedHandler_Implementation(const FModioProgressWidgetValueChanged& Handler) override;\n   virtual void SetColorOverride_Implementation(FLinearColor Override) override;\n   virtual void ClearColorOverride_Implementation() override;\n   virtual float GetProgress_Implementation() override;\n   virtual void SetProgress_Implementation(float NewProgressValue) override;\n   virtual void SetMarquee_Implementation(bool bNewIsMarquee) override;\n};\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsxs)(n.li,{children:["Use the functionality of ",(0,i.jsx)(n.code,{children:"UProgressBar"})," to implement the interface functions. Your progress bar component is now ready to use."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"MyProgressBar.cpp"}),":"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "UI/Components/Buttons/MyProgressBar.h"\n\nvoid UMyProgressBar::AddValueChangedHandler_Implementation(const FModioProgressWidgetValueChanged& Handler)\n{\n   OnProgressValueChanged.AddUnique(Handler);\n}\nvoid UMyProgressBar::RemoveValueChangedHandler_Implementation(const FModioProgressWidgetValueChanged& Handler)\n{\n   OnProgressValueChanged.Remove(Handler);\n}\n\nvoid UMyProgressBar::SetColorOverride_Implementation(FLinearColor Override)\n{\n   SetFillColorAndOpacity(Override);\n}\n\nvoid UMyProgressBar::ClearColorOverride_Implementation()\n{\n   if (DefaultFillColor.IsSet())\n   {\n   \tSetFillColorAndOpacity(DefaultFillColor.GetValue());\n   }\n}\n\nfloat UMyProgressBar::GetProgress_Implementation()\n{\n   return GetPercent();\n}\n\nvoid UMyProgressBar::SetProgress_Implementation(float NewProgressValue)\n{\n   SetPercent(NewProgressValue);\n   OnProgressValueChanged.Broadcast(NewProgressValue);\n}\n\nvoid UMyProgressBar::SetMarquee_Implementation(bool bNewIsMarquee) \n{\n   SetIsMarquee(bNewIsMarquee);\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},39353:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/customcomp-AddClickedHandler-4884ff7c07eddba74de6e1d42c2439ca.png"},91848:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/customcomp-AddInterfaces-14cf9281406b9e2a753c7c4bca5f57eb.png"},10431:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/customcomp-CallOnClicked-ee8be128adbb7dcdb4181c03d2daab7f.png"},38684:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/customcomp-CreateWBP-ae1ca81ea6deb6073ca3a20f828658bd.png"},73098:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/customcomp-EventDispatcher-f64d0e4d6ed6deb038ddc1a240e61725.png"},16974:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/customcomp-ExistingWidget-69fcde3f028e3800bf98e58264d6c034.png"},30382:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/customcomp-FinishedWBP-eb2682f9e8c2b21e7ea649ec89019540.png"},74756:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/customcomp-RemoveClickedHandler-e4cab28f915432c952f03c33bb24d8b4.png"},70835:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/customcomp-SetSelectedState-79eff92c808a29e6dce44c07d2ebfda2.png"},47534:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/customcomp-WrappedWidget-4fa2eef97ed1909ebafb1839f950d312.png"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var i=t(96540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);